<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokémon Collection Tracker</title>
    <!-- Add to Home Screen / PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#facc15">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Simple scrollbar styling for a cleaner look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563; /* gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }
        /* Custom class for collected Pokémon */
        .collected {
            border-color: #22c55e !important; /* green-500 */
            background-color: rgba(34, 197, 94, 0.1);
        }
        .collected-dot {
            opacity: 1 !important;
        }
        /* Modal transition */
        #pokedex-modal.hidden {
            display: none;
        }
        .stat-bar-fill {
            transition: width 0.5s ease-in-out;
        }
        /* Animation for loading dots */
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1.0); }
        }
        .loading-dot {
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .loading-dot:nth-child(1) { animation-delay: -0.32s; }
        .loading-dot:nth-child(2) { animation-delay: -0.16s; }

        /* Moves list scrollbar */
        #moves-list::-webkit-scrollbar-track {
            background: #374151; /* gray-700 */
        }
        #moves-list::-webkit-scrollbar-thumb {
            background: #6b7280; /* gray-500 */
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="app" class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
        <!-- Header -->
        <header class="mb-8 text-center">
            <h1 class="text-4xl sm:text-5xl font-bold text-yellow-400 tracking-tight">Pokémon Collection Tracker</h1>
            <p class="text-gray-400 mt-2">Now with Regional Forms! Your progress is saved automatically.</p>
        </header>

        <!-- Search and Stats Bar -->
        <div class="sticky top-0 z-10 bg-gray-900/80 backdrop-blur-sm py-4 mb-6">
            <div class="flex flex-col md:flex-row gap-4 items-center">
                <input type="text" id="search-input" placeholder="Search by name or Pokédex number..."
                    class="w-full md:w-1/2 bg-gray-800 border border-gray-700 text-white rounded-lg px-4 py-2 focus:ring-2 focus:ring-yellow-500 focus:outline-none transition">
                <select id="game-filter" class="w-full md:w-1/2 bg-gray-800 border border-gray-700 text-white rounded-lg px-4 py-2 focus:ring-2 focus:ring-yellow-500 focus:outline-none transition">
                    <option value="all">All Pokémon Forms (National Pokédex)</option>
                    <!-- Game options will be injected here -->
                </select>
                <div id="stats" class="text-lg font-semibold text-gray-300 whitespace-nowrap">
                    Collected: <span id="collected-count" class="text-green-400 font-bold">0</span> / <span id="total-count" class="text-yellow-400 font-bold">...</span>
                </div>
            </div>
        </div>

        <!-- Pokémon Grid -->
        <div id="loader" class="flex flex-col justify-center items-center h-64">
             <!-- Initial loader content from HTML -->
             <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-yellow-400"></div>
             <p id="loader-text" class="mt-4 text-yellow-400">Fetching Pokémon data...</p>
        </div>
        <div id="pokemon-grid" class="hidden grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 xl:grid-cols-10 gap-3">
            <!-- Pokémon cards will be injected here by JavaScript -->
        </div>

        <!-- Toast Notification -->
        <div id="toast" class="fixed bottom-5 right-5 bg-gray-800 border border-gray-700 text-white px-6 py-3 rounded-lg shadow-lg transform translate-y-20 opacity-0 transition-all duration-300 z-50">
            <p id="toast-message"></p>
        </div>
    </div>

    <!-- Pokédex Modal -->
    <div id="pokedex-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 z-40 flex items-center justify-center p-4 transition-opacity duration-300" role="dialog" aria-modal="true">
        <div id="modal-content" class="bg-gray-800 rounded-xl shadow-lg w-full max-w-lg transform scale-95 transition-transform duration-300 max-h-[90vh] overflow-y-auto">
            <!-- Modal content will be injected here -->
        </div>
    </div>


    <script type="module">
        // --- Firebase SDK Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- PWA Service Worker Registration ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Using relative path './sw.js'
                navigator.serviceWorker.register('./sw.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }

        // --- DOM Elements ---
        const grid = document.getElementById('pokemon-grid');
        const searchInput = document.getElementById('search-input');
        const gameFilter = document.getElementById('game-filter');
        const loader = document.getElementById('loader');
        const collectedCountEl = document.getElementById('collected-count');
        const totalCountEl = document.getElementById('total-count');
        const toast = document.getElementById('toast');
        const toastMessage = document.getElementById('toast-message');
        const modal = document.getElementById('pokedex-modal');
        const modalContent = document.getElementById('modal-content');

        // --- App State ---
        let allPokemon = []; // The complete, final list (including all forms)
        let currentlyDisplayedPokemon = []; // The list currently visible in the grid
        let collection = new Set();
        let toastTimeout;
        const pokemonDetailsCache = {};
        const gamePokemonCache = {}; // Cache for game filter results

        // --- Firebase State ---
        let app, db, auth, userId;
        let isPersistenceEnabled = false; // Flag to control collection saving
        const POKEMON_COLLECTION = 'pokemonCollection';

        // --- Type Colors ---
        const typeColors = {
            normal: 'bg-gray-400', fire: 'bg-red-500', water: 'bg-blue-500', electric: 'bg-yellow-400', grass: 'bg-green-500', ice: 'bg-cyan-300 text-gray-800', fighting: 'bg-orange-700', poison: 'bg-purple-600', ground: 'bg-yellow-600', flying: 'bg-indigo-400', psychic: 'bg-pink-500', bug: 'bg-lime-500', rock: 'bg-stone-500', ghost: 'bg-indigo-800', dragon: 'bg-violet-700', dark: 'bg-gray-700', steel: 'bg-slate-500', fairy: 'bg-pink-300 text-gray-800'
        };

        // --- Utility Functions for Network Resilience ---
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function fetchWithRetry(url, retries = 3, options = {}) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        if (i === retries - 1) throw new Error(`Final attempt failed with status: ${response.status}`);
                        throw new Error(`Attempt ${i + 1} failed with status: ${response.status}`);
                    }
                    return response;
                } catch (error) {
                    console.warn(`Fetch attempt ${i + 1} failed for ${url}. Retrying...`, error.message);
                    if (i < retries - 1) {
                        await delay(1000 * (i + 1)); // Delay: 1s, 2s, 3s...
                    } else {
                        throw new Error(`Failed to fetch ${url} after ${retries} attempts.`);
                    }
                }
            }
        }
        // --- Initialization and Data Loading ---

        async function initializeFirebase() {
            const firebaseConfigStr = typeof __firebase_config !== 'undefined' ? __firebase_config : '{}';
            
            try {
                const firebaseConfig = JSON.parse(firebaseConfigStr);
                if (!firebaseConfig.apiKey) throw new Error("Missing API Key");

                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                isPersistenceEnabled = true;

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        await loadCollectionFromFirestore();
                        // Re-render to show collected status immediately after data is loaded
                        renderPokemon(currentlyDisplayedPokemon, gameFilter.value === 'all' ? null : gamePokemonCache[gameFilter.value.split(',')[0].trim()]);
                    } else if (typeof __initial_auth_token === 'undefined') {
                        await signInAnonymously(auth);
                    }
                });

                if (typeof __initial_auth_token !== 'undefined' && !auth.currentUser) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                }

            } catch (error) {
                console.warn("Persistence Disabled: Firebase configuration error detected. Collection saving is unavailable.", error);
                isPersistenceEnabled = false;
            }
        }

        // --- Core Application Logic (Refactored for non-blocking startup) ---

        async function startDataLoading() {
            // 1. Guaranteed Loader Display
            loader.style.display = 'flex';
            loader.innerHTML = `
                <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-yellow-400"></div>
                <p class="mt-4 text-yellow-400">Fetching Pokémon data (Quick Load)...</p>
            `;
            grid.classList.add('hidden');

            try {
                // 2. Fast Initial Load (Gen 1)
                const initialPokemon = await fetchInitialPokemonList();
                allPokemon = initialPokemon; // Temporarily use Gen 1 data as the 'allPokemon' list
                currentlyDisplayedPokemon = allPokemon;
                renderPokemon(currentlyDisplayedPokemon); 
                loader.style.display = 'none';
                grid.classList.remove('hidden');
                
                // 3. Detachable Full Load: DO NOT await this Promise. It runs in the background.
                fetchFullDataInBackground();

            } catch (error) {
                console.error("CRITICAL: Failed to load initial Kanto data.", error);
                // If the initial small load fails, show a final, permanent network error.
                loader.style.display = 'flex';
                loader.innerHTML = `<div class="text-center text-red-400"><h3 class="text-xl font-bold">Network Error</h3><p>Could not load initial Pokémon data. Please check your network connection and refresh.</p></div>`;
                grid.classList.add('hidden');
            }
        }

        async function fetchFullDataInBackground() {
            try {
                console.log("Starting full background data fetch and filtering...");
                
                const [fullPokemonList] = await Promise.all([
                    fetchFullPokemonData(),
                    fetchGameFilters()
                ]);
                
                // 4. Update state with the full, comprehensive list
                allPokemon = fullPokemonList;
                allPokemon.sort((a, b) => a.speciesId !== b.speciesId ? a.speciesId - b.speciesId : a.name.localeCompare(b.name));
                currentlyDisplayedPokemon = allPokemon;
                
                // Re-render the grid to show all forms and update total count
                renderPokemon(currentlyDisplayedPokemon); 
                console.log(`Full Pokémon dataset loaded and rendered. Total forms: ${allPokemon.length}`);
                showToast("Full Pokédex data loaded in background!", true);

            } catch (error) {
                // Background failure: Log error, but DO NOT interrupt the already loaded Kanto grid.
                console.error("Background Load Failed: Full Pokédex/Filter data could not be loaded. Functionality may be limited.", error);
                showToast("Warning: Full Pokédex data failed to load. Only Gen 1 visible.", false);
            }
        }

        // --- Data Fetching (Updated to use fetchWithRetry and split logic) ---
        
        async function fetchInitialPokemonList() {
             try {
                const response = await fetchWithRetry('https://pokeapi.co/api/v2/pokemon?limit=151', 3);
                const data = await response.json();
                
                // Only return basic data for the first 151
                return data.results.map((p, index) => ({
                    id: `${index + 1}-${p.name}`, 
                    speciesId: index + 1,
                    name: p.name,
                    imageUrl: `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${index + 1}.png`
                }));
            } catch(error) {
                throw new Error(`Failed to load initial Gen 1 data: ${error.message}`);
            }
        }

        async function fetchFullPokemonData() {
            try {
                const speciesResponse = await fetchWithRetry('https://pokeapi.co/api/v2/pokemon-species?limit=1025', 3);
                const speciesData = await speciesResponse.json();
                
                const pokemonList = [];
                const chunkSize = 20; // Load 20 species details at a time
                const speciesResults = speciesData.results;

                for (let i = 0; i < speciesResults.length; i += chunkSize) {
                    const chunk = speciesResults.slice(i, i + chunkSize);
                    
                    // Fire 20 requests in parallel
                    const speciesDetailsPromises = chunk.map(s => fetchWithRetry(s.url).then(res => res.json()));
                    const speciesDetailsChunk = await Promise.all(speciesDetailsPromises); // Await the 20 results

                    // Process varieties
                    for (const species of speciesDetailsChunk) {
                        for (const variety of species.varieties) {
                            const name = variety.pokemon.name;
                            if (name.includes('-gmax') || name.includes('-totem') || name.includes('starter') || name.includes('partner')) continue;
                            
                            const pokemonUrlParts = variety.pokemon.url.split('/');
                            const pokemonId = parseInt(pokemonUrlParts[pokemonUrlParts.length - 2]);
                            
                            pokemonList.push({
                                id: `${species.id}-${name}`,
                                speciesId: species.id,
                                name: name,
                                imageUrl: `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${pokemonId}.png`
                            });
                        }
                    }
                }
                
                return pokemonList;

            } catch (error) {
                throw new Error(`Failed to fetch full Pokémon list and forms: ${error.message}`);
            }
        }

        async function fetchGameFilters() {
            try {
                const response = await fetchWithRetry('https://pokeapi.co/api/v2/version-group?limit=40');
                const data = await response.json();
                const versionGroupDetails = await Promise.all(data.results.map(vg => fetchWithRetry(vg.url).then(res => res.json())));

                const internationalVersionGroups = (await Promise.all(versionGroupDetails.map(async (vg) => {
                    if (!vg.versions || vg.versions.length === 0) return null;
                    const versionData = await fetchWithRetry(vg.versions[0].url).then(res => res.json());
                    return versionData.names.some(name => name.language.name === 'en') ? vg : null;
                }))).filter(Boolean);
                
                const dlcGroups = { 'sword-shield': ['the-isle-of-armor', 'the-crown-tundra'], 'scarlet-violet': ['the-teal-mask', 'the-indigo-disk'] };
                const processedGroups = new Set();

                internationalVersionGroups.forEach(vg => {
                    if (processedGroups.has(vg.name)) return;
                    if (Object.values(dlcGroups).flat().includes(vg.name)) return;
                    addOption(vg.name, formatGameName(vg.name));
                    processedGroups.add(vg.name);
                    if (dlcGroups[vg.name]) {
                        const relatedDlcs = internationalVersionGroups.filter(ivg => dlcGroups[vg.name].includes(ivg.name));
                        relatedDlcs.forEach(dlc => {
                            addOption(dlc.name, `↳ ${formatGameName(dlc.name)}`);
                            processedGroups.add(dlc.name);
                        });
                        if (relatedDlcs.length > 0) {
                            const allGroupNames = [vg.name, ...relatedDlcs.map(d => d.name)].join(',');
                            addOption(allGroupNames, `${formatGameName(vg.name)} (Complete Edition)`);
                        }
                    }
                });
            } catch (error) {
                throw new Error(`Failed to load game filters: ${error.message}`);
            }
        }
        
        async function fetchPokemonEntriesForVersionGroup(groupName) {
            if (gamePokemonCache[groupName]) return gamePokemonCache[groupName];
            const response = await fetchWithRetry(`https://pokeapi.co/api/v2/version-group/${groupName}`);
            const data = await response.json();
            const pokedexUrl = (data.pokedexes.find(p => !p.name.includes("updated")) || data.pokedexes[0])?.url;
            if(!pokedexUrl) throw new Error(`No Pokedex found for ${groupName}`);

            const pokedexData = await fetchWithRetry(pokedexUrl).then(res => res.json());
            const orderedEntries = pokedexData.pokemon_entries.map(entry => ({
                pokedexNumber: entry.entry_number,
                speciesId: parseInt(entry.pokemon_species.url.split('/').slice(-2, -1)[0])
            })).sort((a, b) => a.pokedexNumber - b.pokedexNumber);
            
            gamePokemonCache[groupName] = orderedEntries;
            return orderedEntries;
        }

        async function fetchPokemonDetails(pokemonName) {
            if (pokemonDetailsCache[pokemonName]) return pokemonDetailsCache[pokemonName];
            try {
                const pokemonRes = await fetchWithRetry(`https://pokeapi.co/api/v2/pokemon/${pokemonName}`);
                if (!pokemonRes.ok) throw new Error('Pokemon data not found');
                const data = await pokemonRes.json();
                const speciesRes = await fetchWithRetry(data.species.url);
                const speciesData = await speciesRes.json();
                const flavorTextEntry = speciesData.flavor_text_entries.find(entry => entry.language.name === 'en');
                const flavorText = flavorTextEntry ? flavorTextEntry.flavor_text.replace(/[\n\f]/g, ' ') : 'No description available.';
                const details = {
                    id: `${speciesData.id}-${data.name}`, speciesId: speciesData.id, name: data.name,
                    imageUrl: data.sprites.other['official-artwork'].front_default || data.sprites.front_default,
                    types: data.types.map(t => t.type.name), height: data.height / 10, weight: data.weight / 10,
                    abilities: data.abilities.map(a => a.ability.name.replace(/-/g, ' ')),
                    stats: data.stats.map(s => ({ name: s.stat.name, value: s.base_stat })),
                    moves: data.moves.map(m => m.move.name.replace(/-/g, ' ')).filter((v, i, a) => a.indexOf(v) === i).sort(),
                    flavorText
                };
                pokemonDetailsCache[pokemonName] = details;
                return details;
            } catch (error) {
                console.error(`Failed to fetch details for Pokémon ${pokemonName}:`, error);
                return null;
            }
        }
        
        async function getAIStrategyGuide(details) {
            if (pokemonDetailsCache[details.name]?.strategyGuide) return pokemonDetailsCache[details.name].strategyGuide;

            // FIX: If running on external host (persistence disabled), return a mock strategy immediately.
            if (!isPersistenceEnabled) {
                console.warn("AI Strategy Guide: Returning mock response due to external hosting environment.");
                const mockStrategy = {
                    nature: "Jolly or Adamant",
                    heldItem: "Choice Scarf or Life Orb",
                    evDistribution: {
                        spread: "252 Atk / 4 SpD / 252 Spe",
                        ivs: "Max IVs in HP, Atk, Def, SpD, Spe. 0 Atk IVs if special."
                    },
                    strategy: "This mock strategy outlines a fast, offensive physical sweeper role. Maximize Attack and Speed to hit hard and outspeed threats. Use Choice Scarf to secure speed control or Life Orb for maximum damage output.",
                    moveset: [
                        { name: "Mock Move 1", reason: "A strong STAB attack to deal reliable damage." },
                        { name: "Mock Move 2", reason: "Coverage move to hit common counter-types super effectively." },
                        { name: "Mock Move 3", reason: "Utility move for setting up or status application." },
                        { name: "Mock Move 4", reason: "A powerful, high-risk attack for late-game sweeps." }
                    ]
                };
                pokemonDetailsCache[details.name].strategyGuide = mockStrategy;
                return mockStrategy;
            }

            // Original logic for Canvas environment
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const statsString = details.stats.map(s => `${s.name}: ${s.value}`).join(', ');
            const prompt = `Given the following Pokémon data, provide a detailed strategy guide in a minified JSON format. The JSON object must have these exact keys: "nature", "heldItem", "evDistribution", "strategy", and "moveset". - "nature" must be a string. - "heldItem" must be a string. - "evDistribution" must be an object with two string keys: "spread" (e.g., "252 SpA / 4 SpD / 252 Spe") and "ivs" (e.g., "0 Atk IVs, max all others"). - "strategy" must be a concise paragraph (2-3 sentences). - "moveset" must be an array of exactly 4 objects, where each object has a "name" (string) and "reason" (string). Pokémon: ${formatPokemonName(details.name)}, Types: ${details.types.join('/')}, Abilities: ${details.abilities.map(capitalize).join('/')}, Base Stats: ${statsString}.`;
            try {
                const response = await fetchWithRetry(apiUrl, 1, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }) });
                if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!text) throw new Error("No content in API response.");
                const cleanedText = text.replace(/^```json\s*|```\s*$/g, '').trim();
                const strategyGuide = JSON.parse(cleanedText);
                pokemonDetailsCache[details.name].strategyGuide = strategyGuide;
                return strategyGuide;
            } catch (error) {
                console.error("AI Strategy Guide Error:", error);
                return { error: "Could not generate a strategy guide at this time." };
            }
        }

        // --- Rendering & UI (Functions remain the same) ---
        function renderPokemon(pokemonList, orderMap = null) {
            grid.innerHTML = '';
            if (pokemonList.length === 0) {
                grid.innerHTML = `<p class="col-span-full text-center text-gray-400">No Pokémon found matching your criteria.</p>`;
            } else {
                pokemonList.forEach(pokemon => {
                    const isCollected = collection.has(pokemon.id);
                    const card = document.createElement('div');
                    card.id = `poke-${pokemon.id}`;
                    card.className = `pokemon-card bg-gray-800 border-2 border-gray-700 rounded-lg p-2 text-center cursor-pointer transition-all duration-300 hover:border-yellow-400 hover:scale-105 ${isCollected ? 'collected' : ''}`;
                    
                    const regionalNumber = orderMap ? orderMap.get(pokemon.speciesId) : null;
                    const pokedexNumberDisplay = regionalNumber 
                        ? `#${String(regionalNumber).padStart(4, '0')} <span class="text-gray-500 text-[10px]">(Nat. ${String(pokemon.speciesId).padStart(4, '0')})</span>`
                        : `#${String(pokemon.speciesId).padStart(4, '0')}`;

                    card.innerHTML = `
                        <div class="relative">
                            <div class="collected-dot absolute top-1 right-1 w-3 h-3 bg-green-500 rounded-full ${isCollected ? 'opacity-100' : 'opacity-0'} transition-opacity duration-300"></div>
                            <img src="${pokemon.imageUrl}" alt="${formatPokemonName(pokemon.name)}" class="w-20 h-20 mx-auto" loading="lazy" onerror="this.onerror=null;this.src='https://placehold.co/80x80/374151/9ca3af?text=?';">
                        </div>
                        <p class="mt-2 font-semibold text-sm truncate">${formatPokemonName(pokemon.name)}</p>
                        <span class="text-xs text-gray-400">${pokedexNumberDisplay}</span>`;
                    card.addEventListener('click', () => showPokedexModal(pokemon));
                    grid.appendChild(card);
                });
            }
            updateStats();
        }

        async function showPokedexModal(pokemon) {
            modal.classList.remove('hidden');
            setTimeout(() => modalContent.classList.remove('scale-95'), 10);
            modalContent.innerHTML = `<div class="p-8 flex justify-center items-center h-64"><div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-yellow-400"></div></div>`;

            const details = await fetchPokemonDetails(pokemon.name);
            if (!details) {
                modalContent.innerHTML = `<div class="p-8 text-center text-red-400">Failed to load Pokémon details.</div>`;
                return;
            }

            const isCollected = collection.has(details.id);
            const typesHtml = details.types.map(type => `<span class="px-3 py-1 text-sm font-semibold rounded-full ${typeColors[type] || 'bg-gray-500'}">${capitalize(type)}</span>`).join('');
            const abilitiesHtml = details.abilities.map(ability => `<li class="capitalize">${ability}</li>`).join('');
            const statsHtml = details.stats.map(stat => `
                <div class="flex items-center"><span class="w-1/3 text-sm font-semibold capitalize text-gray-400">${stat.name.replace('special-', 'Sp. ')}</span>
                    <div class="w-2/3 bg-gray-600 rounded-full h-4">
                        <div class="stat-bar-fill h-4 rounded-full bg-yellow-400 text-right pr-2 text-xs font-bold text-gray-900" style="width: 0%;" data-width="${(stat.value / 255) * 100}%">${stat.value}</div>
                    </div></div>`).join('');

            modalContent.innerHTML = `
                <div class="p-6 relative">
                    <button id="close-modal" class="absolute top-4 right-4 text-gray-400 hover:text-white transition text-3xl leading-none">&times;</button>
                    <div class="text-center">
                        <img src="${details.imageUrl}" alt="${formatPokemonName(details.name)}" class="w-40 h-40 mx-auto -mt-16 mb-2 rounded-full bg-gray-700/50 shadow-lg" onerror="this.onerror=null;this.src='https://placehold.co/160x160/4b5563/ffffff?text=?';">
                        <h2 class="text-3xl font-bold">${formatPokemonName(details.name)} <span class="text-gray-400 text-2xl font-normal">#${String(details.speciesId).padStart(4, '0')}</span></h2>
                        <div class="flex justify-center gap-2 my-3">${typesHtml}</div>
                    </div>
                    <div class="space-y-4 mt-4 text-sm">
                        <p class="text-center text-gray-300 italic">${details.flavorText}</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-center">
                            <div><strong class="text-gray-400">Height:</strong> ${details.height} m</div>
                            <div><strong class="text-gray-400">Weight:</strong> ${details.weight} kg</div>
                        </div>
                        <div><h3 class="font-bold text-lg mb-2 border-b border-gray-700 pb-1">Abilities</h3><ul class="list-disc list-inside text-gray-300">${abilitiesHtml}</ul></div>
                        <div><h3 class="font-bold text-lg mb-2 border-b border-gray-700 pb-1">Base Stats</h3><div class="space-y-2">${statsHtml}</div></div>
                        <div id="moves-section">
                            <h3 class="font-bold text-lg mb-2 border-b border-gray-700 pb-1 cursor-pointer flex justify-between items-center" id="moves-header">
                                <span>Learnable Moves (${details.moves.length})</span>
                                <svg id="moves-arrow" class="w-4 h-4 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                            </h3>
                            <div id="moves-content" class="hidden space-y-2 pt-2">
                                <input type="text" id="move-search-input" placeholder="Search moves..." class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-1.5 text-sm focus:ring-2 focus:ring-yellow-500 focus:outline-none transition">
                                <div id="moves-list" class="max-h-48 overflow-y-auto pr-2 flex flex-wrap gap-2"></div>
                            </div>
                        </div>
                        <div id="ai-strategy-section">
                            <h3 class="font-bold text-lg mb-2 border-b border-gray-700 pb-1">AI Strategy Guide</h3>
                            <div id="ai-loader" class="flex items-center justify-center space-x-2 py-4">
                                <div class="loading-dot w-3 h-3 bg-yellow-400 rounded-full"></div><div class="loading-dot w-3 h-3 bg-yellow-400 rounded-full"></div><div class="loading-dot w-3 h-3 bg-yellow-400 rounded-full"></div>
                            </div>
                        </div>
                    </div>
                    <button id="toggle-collection-btn" class="w-full mt-6 py-3 font-bold rounded-lg transition ${isCollected ? 'bg-red-600 hover:bg-red-700' : 'bg-green-600 hover:bg-green-700'}">${isCollected ? 'Remove from Collection' : 'Add to Collection'}</button>
                </div>`;
            
            setTimeout(() => { document.querySelectorAll('.stat-bar-fill').forEach(bar => bar.style.width = bar.dataset.width); }, 100);
            document.getElementById('close-modal').addEventListener('click', closeModal);
            document.getElementById('toggle-collection-btn').addEventListener('click', () => toggleCollection(details));

            const movesHeader = document.getElementById('moves-header'), movesContent = document.getElementById('moves-content'), movesArrow = document.getElementById('moves-arrow'), moveSearchInput = document.getElementById('move-search-input'), movesListContainer = document.getElementById('moves-list');
            const allMoves = details.moves;
            const renderMoves = (moveList) => {
                movesListContainer.innerHTML = moveList.length === 0 ? '<p class="text-gray-400 text-sm w-full">No matching moves found.</p>' : moveList.map(move => `<span class="bg-gray-600 text-gray-200 text-xs font-medium px-2.5 py-1 rounded-full">${move.split(' ').map(capitalize).join(' ')}</span>`).join('');
            };
            renderMoves(allMoves);
            movesHeader.addEventListener('click', () => { movesContent.classList.toggle('hidden'); movesArrow.classList.toggle('rotate-180'); });
            moveSearchInput.addEventListener('input', (e) => renderMoves(allMoves.filter(move => move.toLowerCase().includes(e.target.value.toLowerCase()))));
            
            const strategy = await getAIStrategyGuide(details);
            const aiSection = document.getElementById('ai-strategy-section');
            document.getElementById('ai-loader').style.display = 'none';
            aiSection.innerHTML += strategy.error ? `<p class="text-red-400 text-center">${strategy.error}</p>` : `<div class="text-sm space-y-2">
                <p><strong class="text-gray-400">Recommended Nature:</strong> ${strategy.nature}</p>
                <p><strong class="text-gray-400">Suggested Held Item:</strong> ${strategy.heldItem}</p>
                ${strategy.evDistribution ? `<p><strong class="text-gray-400">EV Spread:</strong> ${strategy.evDistribution.spread}</p><p><strong class="text-gray-400">IV Priority:</strong> ${strategy.evDistribution.ivs}</p>` : ''}
                <p><strong class="text-gray-400">Strategy:</strong> ${strategy.strategy}</p>
                <h4 class="font-semibold text-base mt-2">Example Moveset:</h4>
                <ul class="list-disc list-inside ml-2">${strategy.moveset.map(m => `<li class="mb-1"><strong class="capitalize text-yellow-400">${m.name.replace(/-/g,' ')}:</strong> <span class="text-gray-300">${m.reason}</span></li>`).join('')}</ul></div>`;
        }

        function closeModal() {
            modalContent.classList.add('scale-95');
            setTimeout(() => modal.classList.add('hidden'), 300);
        }

        function showToast(message, success = true) {
            clearTimeout(toastTimeout);
            toastMessage.textContent = message;
            toast.className = `fixed bottom-5 right-5 text-white px-6 py-3 rounded-lg shadow-lg transform transition-all duration-300 z-50 ${success ? 'bg-green-600' : 'bg-red-600'}`;
            toast.classList.remove('translate-y-20', 'opacity-0');
            toastTimeout = setTimeout(() => toast.classList.add('translate-y-20', 'opacity-0'), 3000);
        }

        // --- Event Handlers & Logic ---
        function toggleCollection(pokemonDetails) {
            const pokemonId = pokemonDetails.id;
            const card = document.getElementById(`poke-${pokemonId}`);
            const btn = document.getElementById('toggle-collection-btn');
            
            if (collection.has(pokemonId)) {
                collection.delete(pokemonId);
                showToast(`${formatPokemonName(pokemonDetails.name)} removed from collection.`, false);
                if(card) card.classList.remove('collected');
                if (btn) { btn.textContent = 'Add to Collection'; btn.className = 'w-full mt-6 py-3 font-bold rounded-lg transition bg-green-600 hover:bg-green-700'; }
            } else {
                collection.add(pokemonId);
                showToast(`${formatPokemonName(pokemonDetails.name)} added to collection!`, true);
                if(card) card.classList.add('collected');
                if (btn) { btn.textContent = 'Remove from Collection'; btn.className = 'w-full mt-6 py-3 font-bold rounded-lg transition bg-red-600 hover:bg-red-700'; }
            }
            updateStats();
            // Only attempt to save if running in a valid Firebase environment
            if (isPersistenceEnabled) {
                saveCollectionToFirestore();
            }
        }

        async function handleGameFilterChange() {
            const selectedValue = gameFilter.value;
            loader.style.display = 'flex';
            grid.classList.add('hidden');
            searchInput.value = '';
            let orderMap = null;

            if (selectedValue === 'all') {
                currentlyDisplayedPokemon = [...allPokemon]; // Use a copy
                currentlyDisplayedPokemon.sort((a, b) => a.speciesId !== b.speciesId ? a.speciesId - b.speciesId : a.name.localeCompare(b.name));
            } else {
                try {
                    const groupsToFetch = selectedValue.split(',');
                    const primaryPokedexOrder = await fetchPokemonEntriesForVersionGroup(groupsToFetch[0].trim());
                    orderMap = new Map(primaryPokedexOrder.map(entry => [entry.speciesId, entry.pokedexNumber]));
                    
                    const allSpeciesIdsInGame = new Set();
                    const allPokedexData = await Promise.all(groupsToFetch.map(group => fetchPokemonEntriesForVersionGroup(group.trim())));
                    allPokedexData.flat().forEach(entry => allSpeciesIdsInGame.add(entry.speciesId));

                    currentlyDisplayedPokemon = allPokemon.filter(p => allSpeciesIdsInGame.has(p.speciesId));
                    currentlyDisplayedPokemon.sort((a, b) => {
                        const orderA = orderMap.get(a.speciesId), orderB = orderMap.get(b.speciesId);
                        if (orderA && orderB) return orderA !== orderB ? orderA - orderB : a.name.localeCompare(b.name);
                        if (orderA) return -1; if (orderB) return 1;
                        return a.speciesId !== b.speciesId ? a.speciesId - b.speciesId : a.name.localeCompare(b.name);
                    });
                } catch (error) {
                    console.error(`Failed to filter by game(s) ${selectedValue}:`, error);
                    showToast(`Could not load data for the selected game(s).`, false);
                    currentlyDisplayedPokemon = allPokemon; 
                }
            }
            
            renderPokemon(currentlyDisplayedPokemon, orderMap);
            loader.style.display = 'none';
            grid.classList.remove('hidden');
        }

        function handleSearch() {
            const searchTerm = searchInput.value.toLowerCase().trim();
            const filteredList = currentlyDisplayedPokemon.filter(p => formatPokemonName(p.name).toLowerCase().includes(searchTerm) || String(p.speciesId).includes(searchTerm));
            
            const currentFilter = gameFilter.value;
            let orderMap = null;
            if (currentFilter !== 'all') {
                const primaryGroup = currentFilter.split(',')[0].trim();
                const cachedOrder = gamePokemonCache[primaryGroup];
                if (cachedOrder) {
                    orderMap = new Map(cachedOrder.map(entry => [entry.speciesId, entry.pokedexNumber]));
                }
            }
            renderPokemon(filteredList, orderMap);
        }
        
        function updateStats() {
            const collectedInView = currentlyDisplayedPokemon.filter(p => collection.has(p.id)).length;
            collectedCountEl.textContent = collectedInView;
            totalCountEl.textContent = currentlyDisplayedPokemon.length;
        }

        // --- Persistence (Firestore) ---
        async function saveCollectionToFirestore() {
            if (!userId) return;
            try {
                await setDoc(doc(db, POKEMON_COLLECTION, userId), { collection: Array.from(collection) });
            } catch (error) {
                console.error("Error saving collection to Firestore:", error);
                showToast('Could not save progress.', false);
            }
        }

        async function loadCollectionFromFirestore() {
            if (!userId) return;
            try {
                const docSnap = await getDoc(doc(db, POKEMON_COLLECTION, userId));
                if (docSnap.exists()) collection = new Set(docSnap.data().collection);
            } catch (error) {
                console.error("Error loading collection from Firestore:", error);
            }
        }

        // --- Utility Functions ---
        function capitalize(str) { return str.charAt(0).toUpperCase() + str.slice(1); }
        function addOption(value, text) { const option = document.createElement('option'); option.value = value; option.textContent = text; gameFilter.appendChild(option); }
        function formatGameName(name) { return name.split('-').map(capitalize).join(' / '); }
        function formatPokemonName(name) {
            const parts = name.split('-');
            if (parts.length === 1) return capitalize(parts[0]);
            const regionMap = { 'alola': 'Alolan', 'galar': 'Galarian', 'hisui': 'Hisuian', 'paldea': 'Paldean' };
            if (regionMap[parts[1]]) return `${regionMap[parts[1]]} ${capitalize(parts[0])}`;
            return parts.map(p => p.length === 1 ? p.toUpperCase() : capitalize(p)).join(' ');
        }

        // --- Event Listeners ---
        searchInput.addEventListener('input', handleSearch);
        gameFilter.addEventListener('change', handleGameFilterChange);
        modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
        document.addEventListener('keydown', (e) => { if (e.key === "Escape" && !modal.classList.contains('hidden')) closeModal(); });

        // --- App Initialization ---
        initializeFirebase(); // Runs in the background to set up persistence
        startDataLoading();   // Immediately starts fetching data and robustly manages the loader UI
    </script>
</body>
</html>

